{
  "title": "Creating a prototype of an online store SPA",
  "text": "This section will describe the step-by-step creation of a simple prototype of a frontend SPA online store. The server part of which is written in node.js using express, a template engine - twig , a database - NeDB, a form module for processing form data, the client part is written in htmlix.\r\n\r\nThis is a ready-made example, we will simply delete from the file `/static/js/front.js` all that is there and insert instead:\r\n```javascript\r\nvar State = {\r\n}\r\nwindow.onload = function(){\r\n///creating an HTMLix instance\r\n \r\n var HM = new HTMLixState(State);\r\n console.log(HM);\r\n }\r\n```\r\n\r\nSo we completely removed the frontend from this example, and we still have the application server, let's figure out how it works:\r\n\r\n* first you need to install all the modules that are not currently available, to do this, enter in the console: `npm install`\r\n* next, type `node app` in the command line\r\n* then go to `localhost:3000`\r\n\r\nSo after clicking on various menu items, we see a working server, without the frontend part because we just deleted it.\r\nNow we will create it again step by step, but first let's figure out how the server works.\r\n\r\nBy going to the address `\"/\"` we are given the top menu with three items, the main page with six product cards, and a list of categories on the left side.\r\n\r\nTo give us all this, the server sends two requests to the database, in one it finds all categories, in the second the first six product cards from the table, then attaches two fields from the product category matching the id to each product card, then gives us the `/views/index.twig` view by passing an array to it with categories - `categories` and an array with product cards `carts`.\r\n\r\nFurther in the view itself `/views/index.twig` we load the site header and the top menu from the `/twig_templates` folder:\r\n\r\n`{% include '/twig_templates/header.twig' %}`\r\n\r\nNext, we create a markup for the main page and the category page, in it we create a list of categories from the array `categories` transmitted from the server:\r\n```html\r\n<section class=\"categories\" >\r\n <ul class=\"nav flex-column\" data-categories=\"array\">\r\n {% for category in categories %}\r\n <li class=\"nav-item\" data-category=\"container\">\r\n <a {% if activeCategory == category.idCategory %}\r\n class=\"nav-link active\" \r\n {% else %}\r\n class=\"nav-link\" \r\n {% endif %} \r\n data-category-click=\"click\" data-category-title=\"text\" data-category-class=\"class\" data-category-data=\"{{ category.idCategory }}\" class=\"nav-link\" href=\"/category/{{ category.idCategory }}\">{{ category.titleCategory }}</a>\r\n </li>\r\n {% endfor %}\r\n </ul>\r\n</section>\r\n```\r\n\r\nSo far, we do not pay attention to the entries in the tag starting with data- all this applies to the frontend and we are not interested yet.\r\n\r\nNext, in the loop, we create all product cards from the `carts` array:\r\n\r\n```\r\n\r\n{% for cart in carts %}\r\n <div data-cart=\"container\" class=\"col-12 col-sm-6 col-lg-4\">\r\n <div class=\"card\" style=\"margin-bottom: 10px;\">\r\n <img data-cart-src_img=\"src\" src=\"/static/upload/{{cart.image}}\" class=\"card-img-top\" alt=\"...\">\r\n <div class=\"card-body\">\r\n <h5 data-cart-title=\"text\" class=\"card-title\">{{cart.title}}</h5>\r\n <h6 data-cart-title_category=\"text\" class=\"card-subtitle mb-2 text-muted\">\r\n {{cart.titleCategory}}\r\n</h6>\r\n <div class=\"row justify-content-between\">\r\n <div class=\"col-6\">\r\n <h5 data-cart-cost=\"text\" class=\"card-title\">{{cart.cost}}</h5>\r\n </div>\r\n <div class=\"col-6\" style=\"padding-right: 0px;\">\r\n <a data-cart-click=\"click\" data-cart-data=\"/cart/{{cart._id}}\" href=\"/cart/{{cart._id}}\" class=\"btn btn-primary btn-sm\">Watch</a>\r\n</div> \r\n </div>\r\n </div>\r\n </div>\r\n </div>\r\n{% endfor %}\r\n\r\n```\r\n\r\nThen at the very end we load footer, in which we connect htmlix.js and frontend.js - our frontend file:\r\n\r\n`{% include '/twig_templates/footer.twig' %}`\r\n\r\nSimilarly for the address `http://localhost:3000/category/:idCategory ` we also load all categories, then search for product cards for this category and then also pass all this to the `/views/index.twig` view.\r\n\r\nAlso, let's immediately look at two addresses: `/json ` and `/category/:idCategory/json` by going to these addresses, we will get an array of product cards in json format instead of representation, for the first address these are the first six cards, and for the second card of the corresponding category - `:idCategory`.\r\n\r\n\r\nNow let's analyze the route `\"/cart/:idCart\"` \r\n\r\nHere we also load all categories, then one card corresponding to `:idCart`, then we also attach two fields from the category table to it, then we give the view `/views/cart.twig\" by passing to it a card - cart and an array with categories categories.\r\n\r\nNext, in the view, we also connect `/twig_templates/header.twig\". Connect the header, then create a list of categories from the categories array.\r\n\r\nWe create a markup for the product card, in it we insert data from the cart object, and also connect one of two template options from the folder `/twig_templates/`: `cart_variant_option.twig` or `cart_variant_radio.twig` which we selected when creating the product category.\r\n\r\n```\r\n<div class=\"col-md-5\" data-cart_single-variant_tmpl=\"render-variant\">\r\n\r\n{%set templ = cart.variant_tmpl%}\r\n<!-- created the set templ variable based on the property of the cart.variant_tmpl object --> \r\n \r\n {%include '/twig_templates/' ~templ ~ '.twig'%}\r\n<!-- dynamically inserted a template from the folder '/twig_templates/' based on a variable with the template name templ -->\r\n\r\n</div>\r\n\r\n```\r\nAt the end of the markup, we connect footer.\r\n\r\nThe route `\"/cart/:idCart/json\"` returns an empty array [], this route is used for a stub.\r\n\r\nSo we know enough about the server to start building an application for three routes so far.\r\n\r\nLet's first deal with the routes `\"/\"` and `\"/category/:idCategory\"`:\r\n\r\nHere the page can be divided into two components: categories and product cards, let's create two components in the application description: categories, cards:\r\n\r\nIn the html code of the file `/views/index.twig` they are already designated as `data-carts`=\"array\" - the carts component, `data-cart`=\"container\" - the cart container of the carts component. `data-categories`=\"array\" is the categories component, `data-category`=\"container\" is the category container of the categories component.\r\n\r\n```javascript\r\nvar State = {\r\n \r\n categories: { //category component\r\n container: \"category\", //container of the category component\r\n props: [ ],\r\n methods: {\r\n\r\n }\r\n},\r\ncarts: { //product card component\r\ncontainer: \"cart\", //product card component container\r\n props: [ ],\r\n methods: { \r\n          } \r\n    } \r\n}\r\n```\r\n\r\nSo we have created two components let's add some properties for the categories component: \r\n\r\n* `\"data\"` - data that contains idCategory ( {{ category.idCategory }} ), \r\n* `\"click\"`- category click handler,\r\n* `class` - access to the category class to change the color of the current category,\r\n* `\"title\"` - access to the text inside the category ( {{ category.titleCategory }} ),\r\n\r\nIn the html code of the file `/views/index.twig` they are already designated as data-category-data=\"{{ category.idCategory }}\", data-category-click=\"click\", data-category-class=\"class\", data-category-title=\"text\".\r\n\r\n\r\nLet's add them to the application description:\r\n\r\n```javascript\r\n categories: {\r\n container: \"category\", \r\n props: [ \"data\", \"click\", 'class', \"title\"],\r\n methods: {\r\n click: function(){\r\n \r\n event.preventDefault(); \r\n console.log(this);\r\n \r\n },\r\n } \r\n },\r\n ```\r\nIn the code above, we added four properties for each category container, and for the \"click\" property, a method that does nothing so far, only cancels the link click and page reload. Let's figure out what we need to do when clicking on a category:\r\n\r\n* 1 - load an array with product cards for further use in order to build a carts component based on the data received.\r\n* 2 - delete the class .active for the previous category and set for the new category.\r\n\r\nFor the first point, let's create the `load_carts` method in the `stateMethods` methods common to the entire application and put the loaded cards in the `carts` variable of the `stateProperties` object - variables common to the entire application;\r\n\r\nFor the second point, we will create a custom \"emiter-click-on-category\" event and listen to it in all category containers to add or remove a class when it occurs, we will call the event in the click method of the category container.\r\n\r\n\r\nLet's change the description of the application:\r\n```javascript\r\nvar State = {\r\n\r\n categories: {\r\ncontainer: \"category\",\r\n// added the listener of the \"emiter-click-on-category\"\r\nevent props: [ \"data\", \"click\", 'class', \"title\", ['listner_click_on_category', \"emiter-click-on-category\", \"\"]],\r\nmethods: {\r\nclick: function(){\r\n\r\n event.preventDefault();\r\n var CategoryID = this.parent.props.data.getProp();\r\n//calling the \"emiter-click-on-category\" event\r\n// by passing data from the data property of the container that was clicked to it\r\n this.rootLink.eventProps[\"emiter-click-on-category\"].setEventProp(categoryId);\r\n\r\n //creating a url based on data from the container's data property,\r\n //one for the history - historyUrl we will need in the future,\r\n// the second to make a request to receive product cards to the address /category/:idCategory/json\r\n\r\n var historyUrl = \"/category/\"+categoryId;\r\n var url = historyUrl+\"/json\";\r\n\r\nlistner_click_on_category: function(){\r\n//in the listener of the category click event, we remove the \"active\" class from all containers\r\n// then install it on the container whose data properties match\r\n// with the data passed to the \"emiter-click-on-category\" event\r\n\r\n this.parent.props.class.removeProp(\"active\");\r\n\r\n if(this.parent.props.data.getProp() == this.emiter.prop){ \r\n this.parent.props.class.setProp(\"active\");\r\n         } \r\n      },\r\n   } \r\n },\r\n carts: {\r\n container: \"cart\",\r\n props: [ ],\r\n methods: {\r\n\r\n     }\r\n},\r\nstateProperties:{ //object for storing common application variables \r\n carts: [], \r\n },\r\nstateMethods: {\r\nfetchCategoryCarts: function(url, callb){\r\n// a general method for loading data from any address with a get request,\r\n//takes the url address and callback function callb in the parameters,\r\n// to which it will transmit the received data \r\n\r\n fetch(url).then((response) => {\r\n if(response.ok) {\r\n return response.json();\r\n } \r\n throw new Error('Network response was not ok');\r\n }).then((json) => {\r\n callb(json); \r\n }).catch((error) => {\r\n console.log(error);\r\n }); \r\n }, \r\n load_carts: function(url){\r\n//the method calls fetchCategoryCarts by passing a callback function to it \r\n // in which we insert data from the server into the carts variable of the stateProperties object\r\n //in the future we will also call the \"emiter-load-carts\" event, which we have not yet created\r\n//this in the methods from the stateMethods object points to rootLink\r\n\r\nvar context = this;\r\n \r\n this.stateMethods.fetchCategoryCarts(url, function(data){\r\n\r\n context.stateProperties.carts = data;\r\n\r\n console.log(data)\r\n //context.eventProps[\"emiter-load-carts\"].setEventProp(data); \r\n\r\n });\r\n },\r\n\r\n },\r\neventEmiters: {//created an object with all user events\r\n\r\n [\"emiter-click-on-category\"] : { //added the \"emiter-click-on-category\" event \r\n prop: [],\r\n},\r\n}\r\n}\r\nwindow.onload = function(){\r\n///creating an HTMLix instance\r\n \r\n var HM = new HTMLixState(State);\r\n console.log(HM);\r\n}\r\n \r\n```\r\n\r\nNow, when we click on a category, the class of the current category changes using the \"emiter-click-on-category\" event, and data is loaded from the server using the `load_carts` method of the stateMethods object, which we save in the carts property of the stateProperties object and output to the console for now.\r\n\r\nWhen clicking on another menu item, or on the product card, an error appears that it cannot find any property, so far we do not pay attention to them, this is due to the fact that we have not created a router and htmlix does not know where to look for templates for them.\r\n\r\nNext, let's add the properties of the `cart` container of the `carts` component : \r\n\r\n* `\"data\"` - data that contains '/cart/:idCart' (\"/cart/{{cart._id}}\" ), \r\n* `\"title_category\"` - category name {{cart.titleCategory}},\r\n* `\"cost\"` - product cost {{cart.cost}},\r\n* `title` - access to the text inside the card ({{cart.title}} ),\r\n* `\"src_img\"` - address of the card image \"/static/upload/{{cart.image}}\",\r\n* `\"click\"` - event handler for clicking on the product card\r\nand also create an additional property of the *carts* array - `listener_load_carts` which will listen to the \"emiter-load-carts\" event - loading product cards, we will call it in the `load_carts` method of the stateMethods object.\r\n\r\nNow let's add all the properties to our `carts` component:\r\n\r\n```javascript\r\n carts: {\r\n//added the listener_load_carts property for the carts array\r\n arrayProps: [ ['listener_load_carts', \"emiter-load-carts\", \"\"] ],\r\n arrayMethods: { \r\n listener_load_carts: function(){ //listening to the \"emiter-load-carts\" event\r\n\r\n this.parent.removeAll(); //clearing the array\r\n\r\n var carts = this.emiter.prop;\r\n\r\n for(var i=0; i<carts.length; i++){\r\n//in the loop, iterate through the resulting array with product cards \r\n \r\n var cart = carts[i];\r\n \r\n var props = { //creating an object with all the properties for the container cart\r\n\r\ntitle: cart.title,\r\ntitle_category: cart.titleCategory,\r\n cost: cart.cost,\r\n src_img: '/static/upload/'+cart.image,\r\n data: \"/\r\nthis.parent.add(props); \r\n //adding a new container by passing in the initial data for the properties\r\n     }\r\n  }\r\n},\r\ncontainer: \"cart\",\r\n//added all the properties for the cart container\r\n props: ['title', \"title_category\", \"cost\", \"click\", \"src_img\", \"data\" ],\r\nmethods: {\r\nclick: function(){ //method for processing clicks on the product card,\r\n//so far just outputs the card url to the console\r\n \r\n event.preventDefault(); \r\n var url = this.parent.props.data.getProp();\r\n console.log(url); \r\n       }\r\n    } \r\n },\r\n```\r\n\r\nAlso, don't forget to uncomment the \"emiter-load-carts\" event call in the `load_carts` method and add a new event to the eventEmiters object:\r\n\r\n```javascript\r\n\r\nload_carts: function(url, context ){\r\n\r\n var context = this;\r\n \r\n this.stateMethods.fetchCategoryCarts(url, function(data){\r\n\r\n context.stateProperties.carts = data;\r\n context.eventProps[\"emiter-load-carts\"].setEventProp(data); \r\n\r\n });\r\n//commented out the call of the \"emiter-load-carts\"\r\n//now we are passing an array of carts received from the server to it,\r\n// in the event handler they can be obtained by calling this.emiter.prop \r\n},\r\n\r\n ///*********************************************\r\n\r\neventEmiters: {\r\n // ------------------------------ \r\n [\"emiter-load-carts\"]: { //added a new event\r\n \r\n prop: \"\",\r\n }\r\n } \r\n\r\n```\r\nWell, now when you click on a category, data is loaded from the server and displayed in the carts component, but when you click on the product card, nothing happens yet, except for the output to the console of the address of the card being viewed `/cart/:idCart`\r\n\r\nNext, we will create a product card component `cart_single`, but before creating it, let's figure out how htmlix works:\r\n\r\nSo when loading a page from the address \"/\" or \"/category/:idCategory\", the server sends us the html code of two components, more precisely three, another \"menu\", but we don't use it yet, we use html code for the carts and categories components, based on this code htmlix creates templates for components, but the template for the `cart_single` component is not passed to us at these addresses, because it is not there. How do we \"load up\" it? \r\n\r\nWe will create the `cart_single` component in the application description and put it in a special object `\"fetchComponents\"` and in the settings `stateSettings.templatePath` we will specify the address at which to download templates for this component, and all the others that will appear. Thus, the application will first create the components that the server sent along with the html, and then after sending the second request to stateSettings.templatePath, it will create the remaining components,located in the fetchComponents object.\r\n\r\nThis is what we would do if we always had the first login to the application from the addresses, \"/\" or \"/category/:idCategory\", and what if we then first download the application from the address `\"/cart/:idCart\"` ? The application will give an error that it cannot find a template for the array of carts, since now it will not be at this address and we now need to put carts in the object `\"fetchComponents\"` a `single_cart` on the contrary to get it from there, because it must be initialized first along with the categories component, what should we do?\r\n\r\nTo solve this problem, we will use `HTMLixRouter()`, before creating an instance of the application, after loading the page, it checks which url address is now and compares it with those that we will indicate to it, and then puts those for which there is no template in the first load into the `\"fetchComponents\" object, after that, initializes the application, so we will avoid creating several versions of the application description for different urls and, accordingly, code duplication.\r\n\r\nSo so far we have three addresses \"/\",\"/category/:idCategory\" and \"/cart/:idCart\", the three main components are carts, categories and `cart_single`. At the first two addresses, the carts and categories components should be initialized first, and at the address \"/cart/:idCart\" - categories and cart_single. \r\n\r\nSo let's create a routes object for them and put it separately he writes the State application in a variable :\r\n```javascript\r\nvar routes = {\r\n \r\n [\"/\"]: { \r\n first: [\"categories\", 'carts'], /// the components that are in the html file on this route are specified in this array, the rest will be loaded from the template, asynchronously in the fetch request\r\n\r\nroutComponent: {\r\nrouter_carts: \"carts\", //component corresponding to this route\r\n}, \r\n templatePath: \"/static/templates/index.html \" // folder for downloading templates\r\n}, \r\n [\"/category/:idCategory\"]: { //sign `:` says that this is a parameter, and no comparison is required with it, only its presence is checked.\r\n \r\n first: [\"categories\", 'carts', \"menu\", \"home_page\"], \r\n\r\n routComponent: { \r\n router_carts: \"carts\", \r\n }, \r\n templatePath: \"/static/templates/index.html\" \r\n }, \r\n[\"/cart/:idCart\"]: { \r\n \r\n first: [\"categories\", 'cart_single'], \r\n\r\n routComponent: {\r\n router_carts: \"cart_single\", \r\n },\r\n templatePath: \"/static/templates/index.html\"\r\n },\r\n}\r\n\r\n```\r\nSo we created three routes for the router, here `router_carts` is a div element in which \"carts\" will be displayed on the first two addresses, and on the third \"cart_single\", in html (in the files `/views/index.twig` and `/views/cart.twig`) it is specified as `data-router_carts=\"router\"`. \r\n\r\n\r\nNext, we will add `cart_single` to the application description along with the following properties:\r\n* `\"variant_tmpl\"` is a property with the type \"render-variant\" for displaying an additional variant of the template (`cart_variant_option.twig` or `cart_variant_radio.twig` depending on the category) in the html code `data-cart_single-variant_tmpl`=\"render-variant\",\r\n* `title\" - Product card name `data-cart_single-title'=\"text\", \r\n* `\"title_category\"` category name,\r\n* `\"manufacture\"` - manufacturer,\r\n* `\"cost\"` - cost,\r\n* `\"description\"` - description,\r\n* ` \"cost_btn\"` the cost in the button,\r\n* `\"src_img\"` picture `data-cart_single-src_img'=\"sgc\", \r\n* `\"data\"` - data with category id to generate url - data-cart_single-data=\"{{cart.category }}\",\r\n* `\"click\"` - category click event in the product card,\r\n* ` \"listner_click_on_cart\"` user event listener - \"emiter-click-on-cart\", \r\n\r\n\r\n```\r\ncart_single: {\r\n container: \"cart_single\",\r\n\r\n //for now, we will comment out the properties with component variants, since we have not yet created the components themselves.\r\n props: [\r\n /*\"variant_tmpl\"*/, 'title', \"title_category\", \"manufacture\", \"cost\", \"description\", \r\n \"cost_btn\", \"src_img\", [\"listner_click_on_cart\", \"emiter-click-on-cart\", \"\"], \r\n \"click\", \"data\"\r\n ],\r\nmethods: {\r\n\r\nlistner_click_on_cart: function(){\r\n\r\nvar index = this.emiter.geteventprop();\r\n//getting the index of the card container clicked on in the carts component\r\n\r\n var cart = this.rootLink.stateProperties.carts[index];\r\n //we select from the cards loaded earlier in the array the one we need by the container index \r\n \r\n var props = {\r\n \r\n title: cart.title,\r\n title_category: cart.titleCategory,\r\n cost: cart.cost,\r\n src_img: '/static/upload/'+cart.image,\r\n data: cart.category,\r\n description: cart.description,\r\n cost_btn: cart.cost,\r\n manufacture: cart.manufacture,\r\n// variant_tmpl: cart.variant_tmpl, for now we will comment on the installation of the template variant, because we have not yet created components for them.\r\n \r\n }\r\n \r\n this.parent.setAllProps(props);\r\n //set new values for all properties at once, using the setAllProps(props) method;\r\n},\r\nclick: function(){\r\nevent.preventDefault();\r\n//we will create this method a little later, for now we just output the category id to the console\r\nconsole.log(this.parent.props.data)\r\n}\r\n},\r\n},\r\n\r\n``` \r\nNext, we will add additional code to the `click` method of the 'cart' container of the `carts` component\r\n\r\n```\r\nclick: function(){ \r\n \r\n event.preventDefault(); \r\n var url = this.parent.props.data.getProp(); //in the data property of the cart container, we have the url of the product line. \r\n\r\n //added a call to the \"emiter-click-on-cart\" event, which we listen to in the single_cart component and update the data of all properties\r\n//we pass the index of the container clicked to it\r\n\r\nthis.rootLink.eventProps[\"emiter-click-on-cart\"].setEventProp(this.parent.index);\r\n \r\n //calling the setRout method by passing a new url to it,\r\n// so that the router changes the carts component to cart_single in the div element with data-router_carts=\"router\" \r\n\r\n this.rootLink.router.setRout(url); \r\n}\r\n\r\n```\r\nNext, add a new \"emiter-click-on-cart\" event to the eventEmiters object\r\n\r\n```\r\n eventEmiters: {\r\n \r\n [\"emiter-click-on-cart\"]: {\r\n \r\n prop: \"\",\r\n},\r\n```\r\nAnd also to the end of the click method of the category container of the categories component:\r\n\r\n```javascript\r\nclick: function() {\r\n \r\n //the setRout method takes the url and compares it with the map we created in the routes object\r\n //sets the carts component in the div tag `data-router_carts=\"router\"` \r\n /* ............ end of method ............*/\r\nthis.rootLink.router.setRout(historyUrl); \r\n}\r\n```\r\nAnd don't forget to replace the method of loading the application, now we pass our routes and the description of the State application to the HTMLixRouter() function.\r\n```javascript\r\nwindow.onload = function(){\r\n\r\n ///creating an HTMLix instance\r\n var HM = HTMLixRouter(State, routes);\r\n \r\n var url = window.location.pathname;\r\n \r\n if(window.location.pathname == \"/\"){\r\n \r\n url = url+\"json\";\r\n \r\n }else{\r\n \r\n url = url + \"/json\";\r\n }\r\n\r\n//we send a request to load an array with all product cards when\r\nthe HM.stateMethods application is first loaded.fetchCategoryCarts(url, function(arr){ HM.stateProperties.carts = arr; });\r\n console.log(HM);\r\n}\r\n```\r\n\r\nWell, now our application works for three urls, except for changing the template option for `single_cart` and clicking on the category from `single_cart'. Let's call out and see that everything is in order.\r\n\r\nNext, let's create two new components in the application description - to change the template option in the single cart component:\r\n\r\n``` \r\n cart_variant_option: {\r\n container: \"cart_variant_option\", // views/twig_templates/ data-cart_variant_option=\"container\"\r\n\r\n props: [\"click\", \"select\"], //data-cart_variant_option-select=\"select\" , data-cart_variant_option-click=\"click\"\r\n methods: { \r\n click: function(){\r\n \r\n console.log(this.parent.props.select.getProp());\r\n }\r\n }\r\n \r\n },\r\n cart_variant_radio: {\r\n selector: \"div:last-of-type\",\r\n container: \"cart_variant_radio_cont\",\r\n props: [\"click\", \"radio\"],\r\n methods: { \r\n \r\n click: function(){\r\n \r\n console.log(this.parent.index+\" --- \"+this.parent.props.radio.getProp());\r\n }\r\n \r\n }\r\n \r\n },\r\n\r\n```\r\nAfter that, we uncomment the `variant_tmpl` property of the `cart_single` container component\r\n\r\n\r\n```\r\ncart_single: {\r\n container: \"cart_single\",\r\n props: [\"variant_tmpl\"\r\n\r\n```\r\n\r\nAnd in the `listner_click_on_cart` method:\r\n\r\n```\r\n var props = {\r\n \r\n title: cart.title,\r\n title_category: cart.titleCategory,\r\n cost: cart.cost,\r\n src_img: '/static/upload/'+cart.image,\r\n data: cart.category,\r\n description: cart.description,\r\n cost_btn: cart.cost,\r\n manufacture: cart.manufacture,\r\n variant_tmpl: cart.variant_tmpl, //commented out\r\n \r\n }\r\n```\r\n\r\nNow, when you click on the product card, we will have a different template in different product categories, and in the variant_tmpl property one of the two components `cart_variant_radio` - laptops and TVs `cart_variant_option ` - cameras.\r\n\r\nNext, let's add the code to the `click` method of the `cart_single` container component so that when we click on a category from inside the product card, the active category also changes and the component displayed in the router changes, however, in order not to duplicate the code, since it will be the same as in the `categories` component, we will inherit from it this method, and we will delete the old one.\r\n\r\n```\r\n cart_single: {\r\n container: \"cart_single\",\r\n \r\n props: [\r\n \"variant_tmpl\", 'title', \"title_category\", \"manufacture\", \"cost\", \"description\", \"cost_btn\", \r\n \"src_img\", [\"listner_click_on_cart\", \"emiter-click-on-cart\", \"\"], \"data\", //\"click\", \r\n [\"click\", \"extend\", \"categories\", \"props\"]///inheriting the property from the \"categories\" component\r\n ],\r\n\r\n/* commented\r\nout the click: function() method{\r\nevent.preventDefault();\r\nconsole.log(this.parent.props.data)\r\n} */\r\n```\r\n\r\nSo we created the first part of the prototype of an online store for three url addresses, the full application script up to this point is given below, that's all for now.\r\n\r\n\r\n```\r\nvar State = {\r\n\r\n categories: {\r\ncontainer: \"category\",\r\n// added the listener of the \"emiter-click-on-category\"\r\nevent props: [ \"data\", \"click\", 'class', \"title\", ['listner_click_on_category', \"emiter-click-on-category\", \"\"]],\r\nmethods: {\r\nclick: function(){\r\n\r\n event.preventDefault();\r\n var CategoryID = this.parent.props.data.getProp();\r\n//calling the \"emiter-click-on-category\" event\r\n// by passing data from the data property of the container that was clicked to it\r\n this.rootLink.eventProps[\"emiter-click-on-category\"].setEventProp(categoryId);\r\n\r\n //creating a url based on data from the container's data property,\r\n //one for the history - historyUrl we will need in the future,\r\n// the second to make a request to receive product cards to the address /category/:idCategory/json\r\n\r\n var historyUrl = \"/category/\"+categoryId;\r\n var url = historyUrl+\"/json\"; \r\n\r\nthis.rootLink.stateMethods.load_carts(url);\r\n \r\n //changing the component in the div tag `data-router_carts=\"router\"` - to carts \r\n this.rootLink.router.setRout(historyUrl); \r\n\r\n },\r\nlistner_click_on_category: function(){\r\n//in the listener of the category click event, we remove the \"active\" class from all containers\r\n// then install it on the container whose data properties match\r\n// with the data passed to the \"emiter-click-on-category\" event\r\n\r\n this.parent.props.class.removeProp(\"active\");\r\n\r\n if(this.parent.props.data.getProp() == this.emiter.prop){ \r\n this.parent.props.class.setProp(\"active\");\r\n }\r\n},\r\n}\r\n},\r\ncarts: {\r\n//added the listener_load_carts property for the carts array\r\n arrayProps: [ ['listener_load_carts', \"emiter-load-carts\", \"\"] ],\r\n arrayMethods: { \r\n listener_load_carts: function(){ //listening to the \"emiter-load-carts\" event\r\nthis.parent.removeAll(); //clearing the array\r\n\r\n var carts = this.emiter.prop;\r\n\r\n for(var i=0; i<carts.length; i++){\r\n//in the loop, iterate through the resulting array with product cards \r\n\r\n var cart = carts[i];\r\n\r\n var props = { //creating an object with all the properties for the cart container\r\n\r\n title: cart.title,\r\n title_category: cart.titleCategory,\r\n cost: cart.cost,\r\n src_img: '/static/upload/'+cart.image,\r\n data: \"/cart/\"+cart._id\r\n }\r\n\r\n this.parent.add(props); \r\n //adding a new container by passing in the initial data for the properties\r\n}\r\n}\r\n},\r\ncontainer: \"cart\",\r\n//added all the properties for the cart container\r\n\r\nprops: ['title', \"title_category\", \"cost\", \"click\", \"src_img\", \"data\" ],\r\nmethods: {\r\nclick: function(){ //method for processing clicks on the product card, \r\n\r\n event.preventDefault(); \r\n var url = this.parent.props.data.getProp(); //in the data property of the cart container, we have the url of the product line.\r\n console.log(url);\r\n \r\n\r\n //added a call to the \"emiter-click-on-cart\" event that we are listening to in the single_cart component \r\n //we pass to it the index of the container that was clicked on\r\n this.rootLink.eventProps[\"emiter-click-on-cart\"].setEventProp(this.parent.index);\r\n\r\n //calling the setRout method by passing a new url to it,\r\n// so that the router changes the carts component to cart_single in the div element with data-router_carts=\"router\" \r\n this.rootLink.router.setRout(url); \r\n\r\n \r\n     }\r\n    } \r\n },\r\n cart_single: {\r\n container: \"cart_single\",\r\n\r\nprops: [\r\n \"variant_tmpl\", 'title', \"title_category\", \"manufacture\", \"cost\", \"description\", \"cost_btn\", \r\n \"src_img\", [\"listner_click_on_cart\", \"emiter-click-on-cart\", \"\"], \"data\", //\"click\",\r\n [\"click\", \"extend\", \"categories\", \"props\"]///inheriting the property from the \"categories\" component\r\n ],\r\n \r\n methods: {\r\n\r\n listner_click_on_cart: function(){\r\n\r\n var index = this.emiter.getEventProp();\r\n//we get the index of the card container that was clicked on in the carts component\r\n\r\n var cart = this.rootLink.stateProperties.carts[index];\r\n //we select from the cards loaded earlier in the array the one we need by the container index \r\n\r\n var props = {\r\n\r\n title: cart.title,\r\n title_category: cart.titleCategory,\r\n cost: cart.cost,\r\n src_img: '/static/upload/'+cart.image,\r\n data: cart.category,\r\n description: cart.description,\r\n cost_btn: cart.cost,\r\n manufacture: cart.manufacture,\r\nvariant_tmpl: cart.variant_tmpl,\r\n\r\n }\r\n\r\n this.parent.setAllProps(props);\r\n //setting new values for all properties at once, using the setAllProps(props) method;\r\n},\r\n/*\r\nclick: function(){\r\nevent.preventDefault();\r\nconsole.log(this.parent.props.data)\r\n} */\r\n},\r\n},\r\ncart_variant_option: {\r\ncontainer: \"cart_variant_option\", // views/twig_templates/ data-cart_variant_option=\"container\"\r\n\r\n props: [\"click\", \"select\"], //data-cart_variant_option-select=\"select\" , data-cart_variant_option-click=\"click\"\r\n methods: { \r\n click: function(){\r\n\r\n console.log(this.parent.props.select.getProp());\r\n }\r\n }\r\n},\r\ncart_variant_radio: {\r\n selector: \"div:last-of-type\",\r\n container: \"cart_variant_radio_cont\",\r\n props: [\"click\", \"radio\"],\r\n methods: { \r\n\r\n click: function(){\r\n\r\n console.log(this.parent.index+\" --- \"+this.parent.props.radio.getProp());\r\n }\r\n\r\n }\r\n\r\n },\r\nstateProperties:{ //object for storing common application variables \r\n carts: [],\r\n},\r\nstateMethods: {\r\nfetchCategoryCarts: function(url, callb){\r\n// a general method for loading data from any address with a get request,\r\n//takes the url address and callback function callb in the parameters,\r\n// to which it will transmit the received data\r\nfetch(url).then((response) => {\r\n if(response.ok) {\r\n return response.json();\r\n } \r\n throw new Error('Network response was not ok');\r\n }).then((json) => {\r\n callb(json); \r\n }).catch((error) => {\r\n console.log(error);\r\n }); \r\n }, \r\n load_carts: function(url){\r\n//the method calls fetchCategoryCarts by passing a callback function to it \r\n // in which we insert data from the server into the carts variable of the stateProperties object\r\n//this in methods from the stateMethods object points to rootLink\r\n \r\n var context = this;\r\n \r\n this.stateMethods.fetchCategoryCarts(url, function(data){\r\n\r\n context.stateProperties.carts = data;\r\n\r\n context.eventProps[\"emiter-load-carts\"].setEventProp(data); \r\n\r\n   });\r\n  },\r\n\r\n },\r\n\r\neventEmiters: {//created an object with all user events\r\n\r\n [\"emiter-click-on-category\"] : { //added the \"emiter-click-on-category\" event \r\n prop: [], \r\n },\r\n [\"emiter-load-carts\"]: { \r\n prop: \"\",\r\n },\r\n [\"emiter-click-on-cart\"]: {\r\n prop: \"\",\r\n }, \r\n } \r\n}\r\n\r\nvar routes = {\r\n\r\n [\"/\"]: { \r\n first: [\"categories\", 'carts'], /// the components that are in the html file are specified in this array, the rest will be loaded from the template, asynchronously in the fetch request\r\nroutComponent: {\r\nrouter_carts: \"carts\", //component corresponding to this route\r\n}, \r\n templatePath: \"/static/templates/index.html \" // folder for downloading templates\r\n}, \r\n [\"/category/:idCategory\"]: { //sign `:` says that this is a parameter, and no comparison is required with it, only its presence is checked\r\n\r\n first: [\"categories\", 'carts', \"menu\", \"home_page\"], \r\n\r\n routComponent: { \r\n router_carts: \"carts\", \r\n }, \r\n templatePath: \"/static/templates/index.html\" \r\n }, \r\n [\"/cart/:idCart\"]: { \r\n\r\n first: [\"categories\", 'cart_single'], \r\n\r\n routComponent: {\r\n router_carts: \"cart_single\", \r\n },\r\n templatePath: \"/static/templates/index.html\"\r\n },\r\n}\r\n\r\nwindow.onload = function(){\r\n\r\n ///creating an HTMLix instance\r\n var HM = HTMLixRouter(State, routes);\r\n\r\n var url = window.location.pathname;\r\n\r\n if(window.location.pathname == \"/\"){\r\n\r\n url = url+\"json\";\r\n\r\n }else{\r\n\r\n url = url + \"/json\";\r\n } \r\n\r\n //we send a request to load an array with all product cards when\r\nthe HM.stateMethods application is first loaded.fetchCategoryCarts(url, function(arr){ HM.stateProperties.carts = arr; });\r\n console.log(HM);\r\n}\r\n\r\n```\r\n\r\n\r\n"
}