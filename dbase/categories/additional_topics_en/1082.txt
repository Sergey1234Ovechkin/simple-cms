{
  "title": "Working with user events",
  "text": "This article will cover the basic principles of working with user events in Htmlix and create a small application of four components: user name input forms, greetings, exit buttons, and an array with application users. \r\n\r\nA ready-made example can be called <a href=\"https://sergeyovechkin .github.io/tests/test-eventProps/index.html \">here</a>\r\n\r\nAfter entering the user's name into the form, the application will display his name in the greeting, exit button and create a new container in the array with users, as well as save the data in localStorage. After reloading the page, it will take the name from localStorage. When you click on the \"log out of profile\" button, it will delete data from all components and a variable from localStorage.\r\n\r\nLet's create four components: an entry form - form, a greeting - greeting, an exit button - logout and an array with all visitors - users_array, and see how we would create communication between them if we did not use user events.\r\n\r\nLet's create html markup of all components:\r\n\r\n```html\r\n\r\n<!-- container component form with two properties input with the property type \"inputvalue\" and click with the type \"click\" -->\r\n\r\n<form data-form=\"container\" class=\"card col-12\">\r\n <div class=\"form-group\">\r\n <label for=\"\">Enter a name</label>\r\n <textarea data-form-input=\"inputvalue\" class=\"form-control\" rows=\"1\"></textarea>\r\n </div>\r\n <button data-form-click=\"click\" type=\"submit\">Submit</button>\r\n</form>\r\n\r\n<!-- container component greeting and user_name property with type - \"text\" -->\r\n\r\n<div data-greeting=\"container\" class=\"col-6 card\"> \r\n <p>Hello: <span data-greeting-user_name=\"text\">guest</span></p>\r\n</div>\r\n\r\n<!-- container component exit button and user_name property with type - \"text\" -->\r\n\r\n<div data-logout=\"container\" class=\"col-6 card\"> \r\n <a href=\"#\"> Log out of profile: ( <span data-logout-user_name=\"text\"></span>)\r\n</a> \r\n</div>\r\n\r\n<!-- component is an array of users, initially with two containers, in each container the user_name property is \"text\" --> \r\n \r\n<div class=\"container-fluid\" style=\"border: 1px solid red; margin-top: 20px;\">\r\n <p> all users:</p>\r\n\r\n<div data-users_array=\"array\" class=\"row\">\r\n \r\n <div data-user=\"container\" class=\"col-4 card\"> \r\n <p>user - \r\n <span data-user-user_name=\"text\">user_name_1</span> \r\n </p> \r\n </div>\r\n\r\n <div data-user=\"container\" class=\"col-4 card\"> \r\n <p>user - \r\n <span data-user-user_name=\"text\">user_name_1</span> \r\n </p> \r\n </div>\r\n \r\n </div> \r\n</div>\r\n \r\n```\r\n\r\nNow let's move them to javascript:\r\n\r\n\r\n```javascript\r\n\r\nvar StateMap = {\r\n \r\n form: {//login form\r\ncontainer: \"form\",\r\nprops: [\"input\", \"click\"],\r\nmethods: {\r\n \r\n click: function(){\r\nevent.preventDefault(); //cancel page reload\r\n\r\n //getting the input property data\r\n var text = this.parent.props.input.getProp(); \r\n console.log(text); \r\n              } \r\n      }, \r\n }, \r\n greeting: {//greeting\r\n \r\n container: \"greeting\",\r\nprops: [ \"user_name\", ],\r\nmethods: {\r\n             }\r\n     },\r\nlogout: { //exit button\r\n \r\n container: \"logout\",\r\nprops: [ \"user_name\", ],\r\nmethods: {\r\n              },\r\n},\r\nusers_array: { //array with users\r\n\r\nprops: [ \"user_name\", ],\r\n methods: { \r\n            }, \r\n },\r\n}\r\nwindow.onload = function(){\r\n \r\n var HM = new HTMLixState(StateMap);\r\n console.log(HM); \r\n}\r\n\r\n```\r\n\r\nIn the example above, we wrote the data of the \"input\" property from the form component to the \"text\" variable. Now we need to display them in the properties of the greeting and logout components, as well as create a new container in the users_array array. To understand why custom events are needed, let's first try to do this in various ways without using them.\r\n\r\n<b>1.</b> method - in the click method of the form itself, go directly to each component and set the text property:\r\n\r\n```javascript\r\n\r\n event.preventDefault();\r\n var text = this.parent.props.input.getProp();\r\n//set values to properties\r\n this.rootLink.state[\"greeting\"].props.user_name.setProp(text);\r\n this.rootLink.state[\"logout\"].props.user_name.setProp(text);\r\n \r\n ///created a new container\r\n this.rootLink.state[\"users_array\"].add({user_name: text});\r\n\r\n```\r\n\r\nThe disadvantage of this approach is obvious, what if we then get data for this property somewhere else? For example, based on localstorage, they will be loaded automatically.\r\n\r\n<b>2.</b> the way is to create a method in the stateMethods object and call it when the data changes:\r\n\r\n```javascript\r\n\r\nstateMethods: {\r\n\r\n //this in stateMethods methods points to rootLink\r\nentryUser: function(text){\r\n\r\n this.state[\"greeting\"].props.user_name.setProp(text);\r\n this.state[\"logout\"].props.user_name.setProp(text);\r\n this.state[\"users_array\"].add({user_name: text});\r\n }\r\n}\r\n\r\n// after loading the page\r\nwindow.onload = function(){\r\n var name = window.localStorage.getItem('user_name');\r\n\r\n if(name)HM.stateMethods.entryUser(name); ///calling the method\r\n}\r\n\r\n//in the form\r\nof click: function(){\r\nevent.preventDefault();\r\n var text = this.parent.props.input.getProp();\r\n this.rootLink.stateMethods.entryUser(text); \r\n}\r\n```\r\n\r\nIn this case, we managed to avoid code duplication, but the problem is that the methods for working with the properties of the component are not inside it, but in external functions. What if, before setting a property, it needs to be formatted somehow, differently for each component, or we will need to set not one property, but several, so it's better when the components themselves work with their properties. \r\n\r\n<b>3.</b> the way is to transfer all the logic of working with properties to components, and create methods in them with which to call certain actions.\r\n```javascript\r\n \r\n greeting: {\r\n \r\n container: \"greeting\",\r\n\r\n //added an auxiliary method for greeting the user\r\n props: [ \"user_name\", [\"greet_user\", \"aux\"] ], \r\n methods: {\r\n \r\n greet_user: function(name){\r\n             this.props.user_name.setProp(name+\" !!!\");\r\n       }\r\n    }\r\n },\r\ncontainer: \"logout\",\r\n\r\n props: [ \"user_name\", [\"set_name\", \"aux\"]], //added an auxiliary method to work with\r\nthe methods component property: {\r\n\r\n set_name: function(name){\r\n                      this.props.user_name.setProp(name);\r\n                      }\r\n \r\n           }, \r\n },\r\n\r\nusers_array: { \r\n arrayProps: [[\"entry_user\", \"aux\"]], ///adding a container with a new user from the array\r\n arrayMethods: {\r\n entry_user: function(name){\r\n          this.add({user_name: name})\r\n        }\r\n}\r\ncontainer: \"user\",\r\nprops: [ \"user_name\", ],\r\nmethods: {\r\n         },\r\n},\r\nstateMethods: { //changed the general\r\nentryUser: function(text) method{\r\n\r\n this.state[\"greeting\"].methods.greet_user(text);\r\n this.state[\"logout\"].methods.set_name(text);\r\n this.state[\"users_array\"].methods.entry_user(text);\r\n  }\r\n}\r\n//then we also call this entryUser method from the form and when loading the page\r\n```\r\n\r\nNow the components are encapsulated, but we access the component by its name. What if we then want to change the name of the component or method, or delete the component altogether, or we will have many such components that listen to the same property. Or we will have many such properties, respectively, we will have to create many such methods. \r\n\r\nTo facilitate this task, you can use custom events. The component subscribes to the event, and when it occurs, it does something with its properties.\r\n\r\nLet's edit the code, now using custom events:\r\n\r\n```javascript\r\n\r\nvar StateMap = {\r\n\r\n eventEmiters: { \r\n //created a user login event emitter \r\n [\"emiter-entry-user\"]: {prop: \"\"}, \r\n },\r\n form: {\r\n container: \"form\",\r\n props: [\"input\", \"click\"],\r\n methods: {\r\n \r\n click: function(){\r\n event.preventDefault();\r\n var text = this.parent.props.input.getProp();\r\n\r\n //called an event in the form and passed data to it\r\n this.rootLink.eventProps[\"emiter-entry-user\"].setEventProp(text); \r\n window.localStorage.setItem('user_name', text); \r\n } \r\n }, \r\n}, \r\ngreeting: {\r\n\r\ncontainer: \"greeting\",\r\nprops: [ \"user_name\", ['listen_entry_user', \"emiter-entry-user\", \"\" ] ], //added an event listener \"emiter-entry-user\"\r\nmethods: {\r\n\r\nlisten_entry_user: function(){\r\n//received data from the event and updated property\r\n this.parent.props.user_name.setProp( this.emiter.getEventProp() );\r\n }, \r\n }, \r\n},\r\nlogout: { \r\n \r\n container: \"logout\",\r\nprops: [ \"user_name\", [\"listen_entry_user\", \"emiter-entry-user\", \"\" ]], //event listener property \"emiter-entry-user\"\r\nmethods: {\r\nlisten_entry_user: function(){\r\n//got data from the event and updated the property \r\n this.parent.props.user_name.setProp( this.emiter.getEventProp() );\r\n},\r\n},\r\n},\r\n// here the event listener is added to the array property, because if you add it to the container, it will be called for each container \r\nusers_array: { \r\n \r\n arrayProps: [ ['listen_entry_user', \"emiter-entry-user\", \"\"] ], //event listener property \"emiter-entry-user\"\r\n arrayMethods: {\r\n\r\nlisten_entry_user: function(){\r\n//got data from the event and created a new container\r\n this.parent.add( {user_name: this.emiter.getEventProp()} );\r\n           }, \r\n }, \r\n container: \"user\",\r\n props: [ \"user_name\", ['listen_exit_user', \"emiter-exit-user\", \"\"] ],\r\n methods: { \r\n            }\r\n }, \r\n},\r\n\r\n}\r\nwindow.onload = function(){\r\n\r\nvar HM = new HTMLixState(StateMap);\r\n var name = window.localStorage.getItem('user_name');\r\n \r\n if(name != null)HM.eventProps[\"emiter-entry-user\"].setEventProp(name); ///called the \"emiter-entry-user\" event when loading the site and passed data\r\nto it }\r\n```\r\nThus, we got rid of the intermediate method \"entryUser\" and simply call the event by passing new data to it in the form and after loading the page.Now if we need to change something in a component, or delete it altogether, we do not need to correct the code in each function, which can be as many as you want. And to unsubscribe from any event, you can simply delete the listener in the component, or temporarily disable it using the disableEvent() method in the subscriber property.\r\n\r\nThe full code of this example, along with the second \"emiter-exit-user\" event, can be viewed <a href=\"https://github.com/SergeyOvechkin/tests/tree/master/test-eventProps \">here</a>.\r\n"
}