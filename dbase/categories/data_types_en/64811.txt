{
  "title": "group",
  "text": "A property with the group type is intended for grouping part or all containers from a virtual array.\r\nWhen initializing this property, htmlix searches the html markup for containers declared inside it and adds them to the groupChild field, and also\r\nadds a reference to their virtual array in the groupArray field.\r\n\r\nIn the future, if you need to add new containers to the group, you can simply call the method:\r\nsetProp({`container_prop1`: \"date1\", `container_prop2`: \"date2\", etc. }) - to add a container to the group, or setProp([ {`container_prop1`: \"date1\", `container_prop2`: \"data2\", etc. }, {`container_prop1`: \"date1\", `container_prop2`: \"date2\", etc. }]) - to overwrite the group.\r\n\r\nHtmlix will create containers for a group from an array that has been saved to the groupArray property. If there are no containers in the group type property during initialization, then, accordingly, a reference to the array will not be created, so when adding new containers to the group, htmlix will try to find a reference to groupArray in the group properties of adjacent containers (if they are not empty) and if it does not find an error. Therefore, when creating a property with the group type, it must either have a container that will be displayed here or a template template in the group property of the null container. Or, when using the Setprop method, directly specify the virtual array from which to take templates:\r\n\r\n```\r\nsetProp( {ComponentName: \"virtual array name\", group: [ {container_prop1: \"date1\", container_prop2: \"date2\", etc. }, {container_prop1: \"date1\", container_prop2: \"date2\", etc. }] } );\r\n\r\n```\r\n\r\nBy opening a property with the `group` type in the console, you can see the following fields:\r\n\r\n* `groupArray` - a reference to a virtual array of containers of this group;\r\n* `groupChild' - a group of containers from a virtual array, the sequence number coincides with the groupId field of a specific container of the group.\r\n\r\nAlso, a property with the `group` type has additional methods:\r\n\r\n* `.removeFromGroup(groupId)` - removes the container from the group as well as from the virtual array, where groupId is the index of the container in the group;\r\n* `.clearGroup()` - removes all containers from this property as well as from the virtual array;\r\n* `.addToGroup(container, insertLocation)` - adds a container to the group and creates fields in it **.groupId** is the index of the group, **.groupprent** is a reference to the property in which the container is located\r\n, where container is the container itself, insertLocation is the position to insert, if not specified, it will insert at the end of the group;\r\n* `reuseGroup(arrayWithObjects)` - is similar to reuseAll(arrayWithObjects) - only not for an array but for a group, the only feature of its operation is\r\nthat the property must contain a reference to the virtual array of this group.groupArray if it is not in this property, then it will try to find it in the properties of adjacent containers, if it does not find it, it will not work.\r\nTherefore, when creating markup, in a property with the group type of a null container, there must be a container that will be displayed here in order to remember a link to it, if you need to create an empty property for all containers and only add containers there in the process, you need to create a template with the type \"template\" and (style=\"display: non\") in order to remember the reference to the group array, or use the `.createNewGroup(groupArr, ComponentName)` method\r\n* `.createInGroup(props, insertLocation)` - creates a container in a virtual array and then adds it to the group at the specified position, if you do not specify it will add it to the end, it requires the presence of the this field to work.groupArray !=null\r\nwhich is added when the application is initialized. Therefore, when creating markup, in a property with the group type of a null container, there must be a container that will be displayed here in order to remember a link to it,\r\nif you need to create an empty property for all containers and only in the process of adding containers there, you need to create a template with the type \"template\" and (style=\"display: non\") in order to remember the reference to the array of the group.\r\n* `.createNewGroup(groupArr, ComponentName)` - if the virtual array of this group is this.groupArray.pathToComponent matches the name `ComponentName` then calls the method `reuseGroup(groupArr)` , if it does not match, deletes everything from the group and creates\r\na new one with containers from the virtual array `ComponentName`, where `groupArr` is an array with objects whose keys are the names of properties, and the data of these keys is the data for properties.\r\n\r\n\r\nCalling the **setProp(val) method** - in a property with the group type:\r\n* if val is an object with initial data for properties in key-value format, the `.createInGroup' method will be called(val, insertLocation)`, insertLocation=val.location\r\n* if val is an array with objects whose keys are property names, it will call the `reuseGroup(val)` method\r\n* if val is an object with fields `val.ComponentName` is the name of a virtual array, `val.group` is an array with objects whose keys are property names, it will call the `.createNewGroup(val.group, val.ComponentName)`\r\nCalling the **removeProp(val) method**\r\n* if not passed the parameter will call `.clearGroup()`\r\n* if passed will call `.removeFromGroup(val=groupID)`\r\n\r\nCalling the **getProp()** method returns an array with objects whose keys will be the names of properties, and the values\r\nobtained from these properties on each container are used based on the getAllProps() method,\r\nif passed by the MapObject={key1: \"\", key2: {ke1: \"\"} } parameter `.getProp(MapObject)`,\r\nreturns properties that only match the names of the key, so you can get an expanded object with all the property values or with all the necessary property values from child containers;"
}