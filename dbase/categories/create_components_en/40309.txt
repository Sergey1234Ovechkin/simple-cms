{
  "title": "Updating an array with different template options",
  "text": "Let's consider a situation when it is necessary to display a complex list, in each paragraph of which there is an additional version of the template, for example, in some paragraphs there is a paragraph with additional text, and in some there is not.\r\n\r\nLet's create a markup for this list:\r\n\r\n```html\r\n\r\n<div class=\"container-fluid\">\r\n <div class=\"row\">\r\n <div class=\"col-12\">\r\n<!---------------------------------> \r\n\r\n <div data-test_array=\"array\" class=\"row\">\r\n<!-- array test_array with containers of the list test_container -->\r\n\r\n<div data-test_container=\"container\" class=\"card col-3\">\r\n<p data-test_container-main_text=\"text\">container 1</p>\r\n <div data-test_container-variant=\"render-variant\"> <!-- property with type render-variant - to display an additional template -->\r\n\r\n<div data-variant_cont_1=\"container\"> <!-- the first version of the template -->\r\n <p data-variant_cont_1-text=\"text\" data-variant_cont_1-style=\"style\" > text of variant 1 </p>\r\n</div>\r\n\r\n</div>\r\n</div>\r\n <div data-test_container=\"container\" class=\"card col-3\">\r\n<p data-test_container-main_text=\"text\">container 2</p>\r\n <div data-test_container-variant=\"render-variant\">\r\n\r\n<div data-variant_cont_2=\"container\"> <!-- the second variant of the template -->\r\n <p data-variant_cont_2-text=\"text\" data-variant_cont_2-style=\"style\" > text of variant 2 </p>\r\n <p data-variant_cont_2-text2=\"text\">additional text</p>\r\n</div>\r\n\r\n</div>\r\n</div>\r\n <div data-test_container=\"container\" class=\"card col-3\">\r\n<p data-test_container-main_text=\"text\">container 3</p>\r\n <div data-test_container-variant=\"render-variant\">\r\n\r\n<div data-variant_cont_1=\"container\"> <!-- the first version of the template -->\r\n <p data-variant_cont_1-text=\"text\" data-variant_cont_1-style=\"style\" > text of option 3 </p> </div>\r\n</div>\r\n\r\n</div>\r\n</div>\r\n\r\n\r\n</div>\r\n\r\n \r\n <!--------------------------------->\r\n\r\n</div> \r\n </div>\r\n</div>\r\n\r\n```\r\n\r\nSo above we created the markup that the server issues at the first request\r\n\r\nNext, create a description of the application:\r\n\r\n\r\n```javascript\r\nvar StateMap = {\r\n \r\n test_array: { //the main template\r\n \r\n container: \"test_container\",\r\n props: [\"variant\", \"main_text\"],\r\n methods: {\r\n \r\n \r\n                }, \r\n },\r\n virtualArrayComponents: {\r\n \r\n var_array_1:{\r\ncontainer: \"variant_cont_1\", //the first variant of the additional template\r\n props: [\"text\", \"style\"],\r\nmethods: {\r\n\r\n\r\n          }\r\n},\r\nvar_array_2:{\r\ncontainer: \"variant_cont_2\", //the second variant of the additional template\r\n props: [\"text\", \"style\", \"text2\"],\r\n methods: {\r\n \r\n \r\n                    } \r\n             }, \r\n    } \r\n}\r\n\r\nwindow.onload = function(){\r\n \r\n var HM = new HtmlixState(StateMap);\r\n \r\n console.log(HM);\r\n \r\n console.log(HM.state[\"test_array\"].getAll());\r\n \r\n \r\n}\r\n\r\n\r\n```\r\n\r\nSo we created an application with all the components, which we then brought to the console.\r\n\r\nNow, for example, we clicked on the pagination button and moved to another page, and the server sent us a json object with data for the new page in a fetch request:\r\n\r\n```javascript\r\n\r\n var resp = [\r\n \r\n {main_text: \"Title 1\", variant: {ComponentName: \"var_array_2\", text: \"new text 1\", style: \"color: red;\", text2: \"additional text1\"} },\r\n {main_text: \"title 2\", variant: {ComponentName: \"var_array_1\", text: \"new text 2\", style: \"color: yellow;\"} },\r\n {main_text: \"title 3\", variant: {ComponentName: \"var_array_2\", text: \"new text 3\", style: \"color: red;\", text2: \"additional text2\"} },\r\n {main_text: \"title 2\", variant: {ComponentName: \"var_array_1\", text: \"new text 2\", style: \"color: yellow;\"} },\r\n \r\n ];\r\n\r\n\r\n```\r\n\r\nSo we got new data from the server, the keys of which are the names of the properties, the first property of the main template is main_text with the type \"text\", and the second property\r\nis variant with the type \"render-variant\" in it the server nested an object with data for an additional template, as well as the name of the additional template ComponentName,\r\n\r\nNow we need to update the interface based on the data received, the first way is to remove everything from the array by calling the .removeAll() method in the array,\r\nthen add new containers in the loop conainer = test_array.add(newProps), then delete the old version of the conainer template in each container.variant.renderChild.remove(true);\r\nthen create a new template variant templ = rootLink.state[ComponentName].add(newProps); Then add a new conainer variant to the container.variant.renderByContainer(templ);\r\n\r\nAnd the second easier way is to call: `HM.state[\"test_array\"].reuseAll(resp)`;\r\nwith new server data. How does it work? firstly, in the response from the server, the keys of the objects must match the names of the properties, secondly, the name of the displayed component\r\nComponentName must be present for properties with the type \"render-variant\", so we simply call the setProp() method on each property and pass data from the object key to it, in the variant key we pass the required ComponentName field with the name of the virtual array,\r\nthe other fields are optional and if they are not specified, it will take them from the template.\r\n \r\n So let's change the application description code:\r\n\r\n```javascript\r\n \r\n window.onload = function(){\r\n \r\n var HM = new HtmlixState(StateMap);\r\n \r\n \r\n var resp = [\r\n \r\n {main_text: \"Title 1\", variant: {ComponentName: \"var_array_2\", text: \"new text 1\", style: \"color: red;\", text2: \"additional text1\"} },\r\n {main_text: \"title 2\", variant: {ComponentName: \"var_array_1\", text: \"new text 2\", style: \"color: yellow;\"} },\r\n {main_text: \"title 3\", variant: {ComponentName: \"var_array_2\", text: \"new text 3\", style: \"color: red;\", text2: \"additional text2\"} },\r\n {main_text: \"title 2\", variant: {ComponentName: \"var_array_1\", text: \"new text 2\", style: \"color: yellow;\"} },\r\n \r\n ];\r\n \r\n window.setTimeout( function(){ \r\n \r\n HM.state[\"test_array\"].reuseAll(resp);\r\n \r\n console.log(HM.state[\"test_array\"].getAll());\r\n \r\n }, 2000);\r\n \r\n \r\n \r\n console.log(HM);\r\n \r\n console.log(HM.state[\"test_array\"].getAll());\r\n\r\n \r\n}\r\n \r\n ```\r\n\r\n* <a href=\"https://github.com/SergeyOvechkin/tests/tree/master/render-variant-virtual-array \"> working code example above </a>\r\n \r\nIn such a simple way, you can create various branches, for example, if each additional option has another option or a list with the type 'group', etc.\r\nthe application will determine the type of property that we want to update and if it is a \"render-variant\" it will change the template option to the one that we specified in the 'ComponentName' and set it to the properties that we passed,\r\nand if it is a \"group\" group, it will delete everything from the group and create a new one from an array with objects that will need to be placed in the key value.\r\n"
}