{
  "title": "Changing the displayed components - fetchComponents",
  "text": "In the example above, we looked at changing the displayed components in a property with the type render-variant, the template for which we downloaded from the template file.js, in a synchronous way. When loading templates in this way, htmlix creates components only after loading template.js file, with the small size of this file, it may be a short time. The disadvantage of this method may manifest itself, for example, if we have index.html just a few components, and in template.there are a lot of js, and you will have to wait until they all load.\r\n\r\nTo avoid this, you can use the second method of creating an application, this is loading all templates with a second fetch request asynchronously. With this method, htmlix does not wait for all templates to load, but creates components for which they already exist in index.html . And those for which there is no fetch sends a request to reload templates and creates them after they are loaded. Thus, the application is already running while we are creating the rest of the components in the background, unnoticed by the application user.\r\n\r\nLet's change the example above and load the template for the `variant2` component in the fetch request:\r\n\r\n```html\r\n<div data-page=\"container\">\r\n <div data-page-variant=\"render-variant\"> \r\n \r\n <div data-variant1=\"container\" >text of the first variant</div>\r\n\r\n</div>\r\n <button data-page-click=\"click\">change option</button>\r\n</div> \r\n\r\n```\r\nNext, create a file template.html and add a template for the variant2 component to it:\r\n\r\n```html\r\n\r\n<div data-variant2=\"container\" data-variant2-content=\"text\">text of the second variant<div>\r\n\r\n\r\n```\r\nAdded a template for variant2, and added the content property.\r\n\r\nNow let's change the description of the application:\r\n\r\n```javscript\r\n \r\n var StateMap ={\r\n page: {\r\n container: \"page\",\r\n props: [\"variant\", \"click\"],\r\n methods: {\r\n \r\n click: function(){\r\n\r\nthis.parent.props.variant.setProp(\"variant2\"); //displaying a new variant\r\n\r\n                       }\r\n\r\n            }\r\n},\r\nvariant1: {\r\ncontainer: \"variant1\",\r\n props: [],\r\nmethods: {\r\n                 }\r\n},\r\nfetchComponents: { //placed the component in a special fetchComponents object, this means that the templates for it need to be searched in the file - templatePath: \"./template.html \" after downloading them.\r\n variant2: {\r\n container: \"variant2\",\r\n props: [\"content\"],\r\n methods: { \r\n                  } \r\n              }, \r\n }\r\n stateSettings: {\r\n templatePath: \"./template.html\"\r\n                       }\r\n }\r\n\r\n```\r\nSo we changed the description of the application above, now varian2 is placed in the fetchComponents object, which means that it needs to be created after the templates are loaded from the templatePath file: \"./template.html \" which we specified in the settings.\r\n\r\n\r\nAfter clicking on the button, we change the displayed component in the property. You can not only change the displayed component, but also immediately set any properties to it: .setProp({ComponentName: \"variant2\", content: \"new content\"}) by passing an object with the name of the new component ComponentName and data for properties as a parameter.\r\n\r\n\r\n"
}